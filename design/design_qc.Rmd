---
title: "QC module design" 
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(teal)
library(teal.devel)
library(hermes)
library(assertthat)
```

## QC module design

We want to design a simple QC module.

## Example data

```{r}
MAE <- multi_assay_experiment # from hermes
mae <- dataset("MAE", MAE)
data <- teal_data(mae) 
```

## Plot/Output function

```{r}
run_qc <- function(object, min_cpm, min_cpm_prop, min_corr, min_depth, filter, annotations) {
  assert_that(
    is(object, "SummarizedExperiment")
  )
  object <- HermesData(object)
  object <- add_quality_flags(object,
                              control = control_quality(min_cpm = min_cpm,
                                                        min_cpm_prop = min_cpm_prop,
                                                        min_corr = min_corr,
                                                        min_depth = min_depth))
  object <- normalize(object)
  object <- filter(object, what = filter, annotation_required = annotations)
  object
}
```

Test it:

```{r}
object <- HermesData(summarized_experiment)

run_qc(
  object,
  min_cpm = 1,
  min_cpm_prop = 0.25,
  min_corr = 0.5,
  min_depth = NULL,
  filter = "genes",
  annotations = "WidthBP"
)
```

## UI function

```{r}
ui_qc <- function(id, datasets, dataname) {
  ns <- NS(id)
  mae <- datasets$get_data(dataname, filtered = TRUE)
  standard_layout(
    output = verbatimTextOutput(ns("qc")),
    encoding = div(
      tags$label("Encodings", class = "text-primary"),
      helpText("Analysis Data:", tags$code(dataname)),
      selectInput(ns("experiment_name"), "Select Experiment", names(mae)),
      sliderInput(ns("min_cpm"), label = ("Minimum CPM"), min = 1, max = 10, value = 5),
      sliderInput(ns("min_cpm_prop"), label = ("Minimum CPM Proportion"), min = 0.01, max = 0.99, value = 0.25),
      sliderInput(ns("min_corr"), label = ("Minimum Correlation"), min = 0.01, max = 0.99, value = 0.5),
      radioButtons(ns("min_depth"), label = ("Minimum Depth"), choices = c("Default", "Specify"), selected = NULL),
      conditionalPanel(condition = paste0("input['", ns("min_depth"), "']" , ".includes('Specify')"), sliderInput(ns("min_depth_continuous"), label = NULL, min = 1, max = 10, value = 5)),
      checkboxGroupInput(ns("filter"), label = ("Filter"), choiceNames = list("Genes", "Samples"), choiceValues = list("genes", "samples"), selected = NULL),
      optionalSelectInput(ns("annotate"), label = "Annotations", choices = "", selected = NULL)
    )
  )
}
```

## Server function

```{r}
srv_qc <- function(input, output, session, datasets, dataname) {

  # Reactive function for experiment data since it is used in multiple places below.
  experiment_data <- reactive({
    req(input$experiment_name)
    
    mae <- datasets$get_data(dataname, filtered = TRUE)
    mae[[input$experiment_name]] 
  })
  
  # When the chosen experiment changes, recompute the annotations available. 
  annotations <- eventReactive(input$experiment_name, {
    object <- experiment_data()
    names(SummarizedExperiment::rowData(object))
  })
  
  # When the chosen experiment changes, recompute the maximum CPM available.
  max_cpm <- eventReactive(input$experiment_name, {
    object <- experiment_data()
    object <- HermesData(object)
    max(edgeR::cpm(hermes::counts(object)))
  })
  
  observeEvent(annotations(), {
    # First: resolve all reactivity.
    annotations <- annotations()

    # Second: do the action.
    updateOptionalSelectInput(
      session,
      "annotate",
      choices = annotations,
      selected = annotations[1]
    )
  })
  
  observeEvent(input$experiment_name, {
    max_cpm <- max_cpm()
    
    updateSliderInput(
      session,
      "min_cpm",
      min = 1,
      max = max_cpm,
      value = 1
    )
  })

  output$qc <- renderPrint({
    # First: resolve all reactivity.
    object <- experiment_data()
    min_cpm <- input$min_cpm
    min_cpm_prop <- input$min_cpm_prop
    min_corr <- input$min_corr
    min_depth <- input$min_depth
    min_depth_continuous <- input$min_depth_continuous
    filter <- input$filter
    annotations <- input$annotate
    
    # Second: validate.
    # add later
    # teal.devel::as.global(experiment_data)
    min_depth <- if (min_depth == "Specify") {
      min_depth_continuous
    } else {
      NULL
    }
    
    # Third: plot
    run_qc(
      object,
      min_cpm = min_cpm,
      min_cpm_prop = min_cpm_prop,
      min_corr = min_corr,
      min_depth = min_depth,
      filter = filter,
      annotations = annotations
    )
  })
}
```

## Teal module function

```{r}
tm_quality_control <- function(label = "Simple MAE module", 
                               info = NULL, 
                               dataname = NULL, 
                               pre_output = NULL, 
                               post_output = NULL) {
  module(
    label = label,
    server = srv_qc,
    ui = ui_qc,
    ui_args = list(dataname = dataname),
    server_args = list(dataname = dataname),
    filters = "all"
  )
}
```

## Try it out

Now we can try it out.

```{r}
app <- init(
  data = data,
  modules = root_modules(
    static = {
      tm_quality_control(
        label = "QC Module",
        dataname = "MAE"
      )
    }
  )
)

shinyApp(app$ui, app$server)
```
